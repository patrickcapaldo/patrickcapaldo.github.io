<!DOCTYPE html> <html> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Buffer Overflow in C | Patrick X. Capaldo</title> <meta name="author" content="Patrick X. Capaldo"> <meta name="description" content="How to exploit programs written in C."> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.22.1/dist/bootstrap-table.min.css"> <link rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?19f3075a2d19613090fe9e16b564e1fe" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%F0%9F%9A%80&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://patrickcap.github.io/blog/2021/buffer-overflow-c/"> <link rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?e74e74bf055e5729d44a7d031a5ca6a5" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js?96d6b3e1c3604aca8b6134c7afdd5db6"></script> <script src="/assets/js/dark_mode.js?9b17307bb950ffa2e34be0227f53558f"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?7b30caa5023af4af8408a472dc4e1ebb"></script> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script src="/assets/js/distillpub/template.v2.js"></script> <script src="/assets/js/distillpub/transforms.v2.js"></script> <script src="/assets/js/distillpub/overrides.js"></script> <style type="text/css">.fake-img{background:#bbb;border:1px solid rgba(0,0,0,0.1);box-shadow:0 0 4px rgba(0,0,0,0.1);margin-bottom:12px}.fake-img p{font-family:monospace;color:white;text-align:left;margin:12px 0;text-align:center;font-size:16px}</style> </head> <body> <d-front-matter> <script async type="text/json">{
      "title": "Buffer Overflow in C",
      "description": "How to exploit programs written in C.",
      "published": "July 21, 2021",
      "authors": [
        {
          "author": "Patrick Capaldo",
          "authorURL": "https://patrickcap.github.io/",
          "affiliations": [
            {
              "name": "None",
              "url": ""
            }
          ]
        }
        
      ],
      "katex": {
        "delimiters": [
          {
            "left": "$",
            "right": "$",
            "display": false
          },
          {
            "left": "$$",
            "right": "$$",
            "display": true
          }
        ]
      }
    }</script> </d-front-matter> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"><span class="font-weight-bold">Patrick </span>X. Capaldo</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about</a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog<span class="sr-only">(current)</span></a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">projects</a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">repositories</a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv</a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fa-solid fa-moon"></i> <i class="fa-solid fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="post distill"> <d-title> <h1>Buffer Overflow in C</h1> <p>How to exploit programs written in C.</p> </d-title><d-byline></d-byline><d-article> <d-contents> <nav class="l-text figcaption"> <h3>Contents</h3> <div><a href="#background">Background</a></div> <div><a href="#analogy">Analogy</a></div> <div><a href="#the-stack">The Stack</a></div> <div><a href="#stack-buffer-overflow-stack-smashing">Stack Buffer Overflow / Stack Smashing</a></div> <div><a href="#protection-and-prevention">Protection and Prevention</a></div> </nav> </d-contents> <h2 id="background">Background</h2> <p>The programming language C is commonly referred to as being an “unsafe” language.</p> <p>However, in the setting of a learning environment, this “unsafe” nature is the perfect medium through which students can be taught the nature of the modern machine - although still abstracted from its true behaviour.</p> <p>One famous example of the unsafe nature of C is demonstrated through an even more famous cybersecurity exploit - the buffer overflow.</p> <h2 id="analogy">Analogy</h2> <p>A buffer overflow can be abstracted with the following example:</p> <p>Imagine you have an empty glass and you ask your friend to give you some water - and you also happen to be wearing your favourite wrist watch. Your friend pours the water but accidentally overfills the glass, spilling water all over your hand and your brand new watch. From here, anything could happen. If you’re lucky, your watch may have survived; if you’re unlucky and water got into the wrong spot, your watch may have died; or maybe the water causes a glitch and your watch starts running backwards. The point is - when the glass overflows, anything might happen.</p> <p>The same is true for buffer overflows in programming. Think of the glass as an array, the water as data being put into the array, and the result of the watch being the response of the program.</p> <p>Sounds dangerous right? That’s because it is, and there are cetain functions in C that make buffer overflows relatively easy for a beginner programmer to induce. Examples of such functions incldude: gets(), sprintf(), strcpy(), and strcat().</p> <h2 id="the-stack">The Stack</h2> <p>We will assume that the array is allocated in the stack (hence we will be analysing a stack buffer overflow). The stack begins at higher addresses and grows towards lower addresses; the top of the stack has the highest address (refer to Figure 1).</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/tutorials/buffer_overflow-c/boc-1-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/tutorials/buffer_overflow-c/boc-1-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/tutorials/buffer_overflow-c/boc-1-1400.webp"></source> <img src="/assets/img/tutorials/buffer_overflow-c/boc-1.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> Figure 1: Basic stack structure. </div> <p>Note that when a function is called on the stack by a “caller”, a “callee” stack frame is created for that function. The stack frame consists of the arguments given, the base pointer of the caller function, local variables (arrays, etc…), and the address of the caller base pointer (i.e. where to go once the callee is finished). The stack utilises two main registers to operate: the “stack pointer” (%esp) and the “base pointer” (%ebp) - where %esp always points to the top of the stack and %ebp points to the frame of the current function (refer to Figure 2).</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/tutorials/buffer_overflow-c/boc-2-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/tutorials/buffer_overflow-c/boc-2-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/tutorials/buffer_overflow-c/boc-2-1400.webp"></source> <img src="/assets/img/tutorials/buffer_overflow-c/boc-2.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> Figure 2: Basic stack frame structure. </div> <p>Knowing this, we can now see how a stack buffer overflow works - also known as “stack smashing”.</p> <h2 id="stack-buffer-overflow--stack-smashing">Stack Buffer Overflow / Stack Smashing</h2> <p>Buffer overflow is achieved by writing to more memory than was allocated for a particular variable (usually a character array). By doing this, metadata of the current stack frame will be overwritten and crucially - there there is a possibility that the return pointer for the caller’s stack frame is also overwritten. If this occurs, once the callee finishes executing, the operating system will not know where to return to since the return address has been corrupted.</p> <p>This can be exploited maliciously by deliberately overwriting the return address value to point back into the buffer that caused the overwrite in the first place (the callee array). Finally, if the attacker filled the array with malicious code, then once the callee “finishes”, the buffer/malicious code will be executed (refer to Figure 3 which displays a buffer overflow caused by a call to get(s)).</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/tutorials/buffer_overflow-c/boc-3-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/tutorials/buffer_overflow-c/boc-3-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/tutorials/buffer_overflow-c/boc-3-1400.webp"></source> <img src="/assets/img/tutorials/buffer_overflow-c/boc-3.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> Figure 3: Stack smashing by overwriting a buffer (array). </div> <p>You may be wondering “sure that would work, but how can an attacker even write over the bounds of an array? Wouldn’t the program give an error or segmentation fault before?” - which is a valid question. However, this is where the unsafe nature of C comes in to play.</p> <p>Using a function like strcpy() to copy user input into an array will allow for writing over the bounds of the array since strcpy() will only finish copying until a null character is found. If the attack places this null character at an index past the bounds of the array - then the array, and hence the callee stack frame, will be successfully overwritten.</p> <p>For example, if the victim allocates a buffer of 200 bytes and copies user input into this buffer using strcpy(), then the attacker can exploit this by giving an input longer than 200 bytes. The attacker’s input will contain their malicious code for execution later, along with the values that will overwrite the return pointers and re-direct them back into their buffer/attacker input.</p> <h2 id="protection-and-prevention">Protection and Prevention</h2> <p>To learn about how to protect against and prevent buffer overflows from occurring, take a look at <a href="https://patrickcap.github.io/blog/2021/buffer-overflow-prot/">this page</a>.</p> </d-article> <d-appendix> <d-footnote-list></d-footnote-list> <d-citation-list></d-citation-list> </d-appendix> <d-bibliography src="/assets/bibliography/2021-07-21-buffer-overflow-c.bib"></d-bibliography> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2024 Patrick X. Capaldo. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>